# 子序列不连续问题

300.最长上升子序列
1143.最长公共子序列
1035.不相交的线

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

[Video](https://www.bilibili.com/video/BV1ng411J7xP/?vd_source=2242793e3815d8c255d1ee53ee2883ed)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

解法：
- dp的含义：dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
- 状态转移方程：位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值
- dp[i]的初始化：每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1
- 确定遍历顺序：dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return 1
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            # 内循环，dp[i]的值为0-(i-1)下标dp最大的值加一
            for j in range(0,i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        
        
        # 最长递增子序列不一定是以i为结尾的dp[i]
        return max(dp)
```


# 子序列连续问题

674.最长连续递增序列
718.最长重复子数组
53.最大子序和

## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/)

[VIDEO](https://www.bilibili.com/video/BV1bD4y1778v?vd_source=2242793e3815d8c255d1ee53ee2883ed&spm_id_from=333.788.videopod.sections)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。


```

```
