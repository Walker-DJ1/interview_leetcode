# 子序列连续问题

300.最长上升子序列
1143.最长公共子序列
1035.不相交的线

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

[Video](https://www.bilibili.com/video/BV1ng411J7xP/?vd_source=2242793e3815d8c255d1ee53ee2883ed)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

解法：
- dp的含义：dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
- 状态转移方程：位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值
- dp[i]的初始化：每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1
- 确定遍历顺序：dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return 1
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            # 内循环，dp[i]的值为0-(i-1)下标dp最大的值加一
            for j in range(0,i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        
        
        # 最长递增子序列不一定是以i为结尾的dp[i]
        return max(dp)
```
