# 区间问题
- 55.跳跃游戏
- 45.跳跃游戏 II
- 452.用最少数量的箭引爆气球
- 435.无重叠区间
- 763.划分字母区间
- 56.合并区间

## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

[VIDEO](https://www.bilibili.com/video/BV1VG4y1X7kB?vd_source=2242793e3815d8c255d1ee53ee2883ed&spm_id_from=333.788.videopod.sections)
``` 
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        i = 0
        cover = 0
        # python不支持动态修改for循环中变量,使用while循环代替
        while i <= cover:
            cover = max(i+nums[i],cover)

            if cover >= len(nums)-1:
                return True
            i += 1
        return False  
        
```
[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/description/)

给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:


[VIDEO](https://leetcode.cn/problems/jump-game-ii/description/)
```
class Solution:
    def jump(self, nums):
        if len(nums) == 1:
            return 0
        
        cur_distance = 0  # 当前覆盖最远距离下标
        ans = 0  # 记录走的最大步数
        next_distance = 0  # 下一步覆盖最远距离下标
        
        for i in range(len(nums)):
            next_distance = max(nums[i] + i, next_distance)  # 更新下一步覆盖最远距离下标
            if i == cur_distance:  # 遇到当前覆盖最远距离下标
                ans += 1  # 需要走下一步
                cur_distance = next_distance  # 更新当前覆盖最远距离下标（相当于加油了）
                if next_distance >= len(nums) - 1:  # 当前覆盖最远距离达到数组末尾，不用再做ans++操作，直接结束
                    break
        
        return ans
```


# others
- 53.最大子序和
- 134.加油站
- 968.监控二叉树
