# 中等题目

序列问题
- 376.摆动序列
- 738.单调递增的数字

贪心解决股票问题
- 122.买卖股票的最佳时机川
- 714.买卖股票的最佳时机含手续费

两个维度权衡问题
- 135.分发糖果
- 406.根据身高重建队列


# 序列问题
- 376.摆动序列
- 738.单调递增的数字

## [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。


[VIDEO](https://www.bilibili.com/video/BV17M411b7NS?vd_source=2242793e3815d8c255d1ee53ee2883ed&spm_id_from=333.788.videopod.sections)
```
class Solution:
    def wiggleMaxLength(self, nums):
        if len(nums) <= 1:
            return len(nums)  # 如果数组长度为0或1，则返回数组长度
        curDiff = 0  # 当前一对元素的差值
        preDiff = 0  # 前一对元素的差值
        result = 1  # 记录峰值的个数，初始为1（默认最右边的元素被视为峰值）
        for i in range(len(nums) - 1):
            curDiff = nums[i + 1] - nums[i]  # 计算下一个元素与当前元素的差值
            # 如果遇到一个峰值
            if (preDiff <= 0 and curDiff > 0) or (preDiff >= 0 and curDiff < 0):
                result += 1  # 峰值个数加1
                preDiff = curDiff  # 注意这里，只在摆动变化的时候更新preDiff
        return result  # 返回最长摆动子序列的长度
```

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组是数组中的一个连续部分。

[VIDEO](https://www.bilibili.com/video/BV1aY4y1Z7ya?vd_source=2242793e3815d8c255d1ee53ee2883ed&spm_id_from=333.788.videopod.sections)
```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 初始化结果为负无穷大
        result = float("-inf")
        count = 0

        for i in range(len(nums)):
            count += nums[i]
            # 取区间累计的最大值（相当于不断确定最大子序终止位置）
            if result < count:
                result = count
            # 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
            if count < 0:
                count = 0
        return result
```    

# 贪心解决股票问题
- 122.买卖股票的最佳时机川
- 714.买卖股票的最佳时机含手续费

  
## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。
[VIDEO](https://www.bilibili.com/video/BV1ev4y1C7na?vd_source=2242793e3815d8c255d1ee53ee2883ed&spm_id_from=333.788.videopod.sections)
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        for i in range(1, len(prices)):
            # 只收集正的收益
            result += max(prices[i]-prices[i-1],0)
        return result
``` 

## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

[VIDEO](https://www.bilibili.com/video/BV1VG4y1X7kB?vd_source=2242793e3815d8c255d1ee53ee2883ed&spm_id_from=333.788.videopod.sections)
``` 
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        i = 0
        cover = 0
        # python不支持动态修改for循环中变量,使用while循环代替
        while i <= cover:
            cover = max(i+nums[i],cover)

            if cover >= len(nums)-1:
                return True
            i += 1
        return False  
        
``` 
