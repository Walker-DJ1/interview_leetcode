# 二叉树的遍历方式
<!-- TOC -->
* [二叉树的遍历方式](#二叉树的遍历方式)
  * [深度优先遍历](#深度优先遍历)
    * [递归解法](#递归解法)
      * [1递归前序遍历](#1递归前序遍历)
      * [2递归中序遍历](#2递归中序遍历)
      * [3递归后序遍历](#3递归后序遍历)
    * [迭代解法](#迭代解法)
      * [1迭代前序遍历迭代](#1迭代前序遍历迭代)
      * [2 迭代中序遍历迭代](#2迭代中序遍历迭代)
      * [3迭代后序遍历迭代](#3迭代后序遍历迭代)
  * [广度优先遍历](#广度优先遍历)
      * [层序遍历](#层序遍历)
<!-- TOC -->


二叉树主要有两种遍历方式：
**深度优先遍历**：先往深走，遇到叶子节点再往回走。
**广度优先遍历**：一层一层的去遍历。

* 深度优先遍历
    * 前序遍历（递归法，迭代法）:中左右
    * 中序遍历（递归法，迭代法）:左中右
    * 后序遍历（递归法，迭代法）:左右中
* 广度优先遍历
    * 层次遍历（迭代法）

这里前中后，其实指的就是中间节点的遍历顺序 前中后序指的就是中间节点的位置就可以了。看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png)
前序遍历：中左右
中序遍历：左中右
后序遍历：左右中

### code
[144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

[145.二叉树的后序遍历]()

[94.二叉树的中序遍历]()

[102.二叉树的层序遍历]()


## 深度优先遍历
### 递归解法
#### 1递归前序遍历
```
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        left=self.preorderTraversal(root.left)
        right=self.preorderTraversal(root.right)

        return [root.val]+left+right
```
#### 2递归中序遍历
```
# 中序遍历-递归-LC94_二叉树的中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if root is None:
            return []

        left = self.inorderTraversal(root.left)
        right = self.inorderTraversal(root.right)

        return left + [root.val] + right

```
#### 3递归后序遍历
```
# 后序遍历-递归-LC145_二叉树的后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []

        left = self.postorderTraversal(root.left)
        right = self.postorderTraversal(root.right)

        return left + right + [root.val]
```

### 迭代解法
#### 1迭代前序遍历迭代
```
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack=[root]
        result=[]
        while stack:
            # 先入后出
            node=stack.pop()
            # 根左右，先处理中节点
            result.append(node.val)

            #右孩子先入栈
            if node.right:
                stack.append(node.right)
            #左孩子后入栈
            if node.left:
                stack.append(node.left)
        return result
```

#### 2迭代中序遍历迭代
```
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        # 用于记录二叉树的访问顺序
        stack=[]
        result=[]
        # 访问的指针位置
        cur=root
        while cur or stack:
            # 先迭代访问最底层的左子树节点
            if cur:
                stack.append(cur)
                cur=cur.left
            # 到左节点后处理栈顶节点
            else:
                cur=stack.pop()
                result.append(cur.val)
                # 取栈顶元素右节点
                cur=cur.right
        return result
```

#### 3迭代后序遍历迭代
```
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        # 前序遍历的思维中左右-->将处理思维变为中右左
        # 返回结果中反转字段串变为左-->右-->中
        stack=[root]
        result=[]
        while stack:
            # 先入后出
            node=stack.pop()
            # 根左右，先处理中节点
            result.append(node.val)
            #左孩子后入栈
            if node.left:
                stack.append(node.left)
            #右孩子先入栈
            if node.right:
                stack.append(node.right)
        # 字符串反转中右左-->左右中        
        return result[::-1]
```

## 广度优先遍历
#### 层序遍历
```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        # 存储层序遍历结果
        res=[]
        # 存储层队列
        queue=collections.deque()
        queue.append(root)
        while queue:
            temp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(temp)
        return res
```